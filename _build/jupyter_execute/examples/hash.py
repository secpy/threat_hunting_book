#!/usr/bin/env python
# coding: utf-8

# # Нечеткое хеширование на Python

# Сравнение подозрительного файла с ранее проанализированными образцами или образцами, хранящимися в публичном либо частном хранилище, может дать представление о семействе вредоносных программ, их характеристиках и сходстве с предварительно проанализированными образцами.
# 
# Хотя криптографические хеш-функции (MD5/SHA1/SHA256) являются отличным методом для обнаружения идентичных образцов, они не помогают в идентификации схожих образцов. Очень часто авторы вредоносных программ меняют мелкие аспекты вредоносных программ, что полностью меняет значение хеш-функции. 

# Нечеткое хеширование – отличный способ сравнить файлы на схожесть. 
# 
# [Ssdeep](https://ssdeep-project.github.io/ssdeep/) – полезный инструмент для создания нечеткого хеша для образца, и он также помогает в определении процентного сходства между
# образцами. Этот метод полезен при сравнении подозрительного файла с образцами из хранилища для идентификации похожих. Это может помочь определить образцы, принадлежащие к одному семейству вредоносных программ или к одной и той же группе субъектов.

# Исходные файлы для блокнота находятся по [ссылке](https://github.com/dm-fedorov/infosec/tree/master/re-tools/samples).

# Скачиваем весь архив с файлами для работы в Colab:

# In[ ]:


get_ipython().system('wget https://dfedorov.spb.ru/infosec/re/samples.zip')


# In[ ]:


get_ipython().system('unzip samples.zip')


# In[ ]:


get_ipython().system('apt-get -y install libfuzzy-dev')


# In[ ]:


get_ipython().system('apt-get install ssdeep')


# In[ ]:


get_ipython().system('pip install ssdeep')


# Чтобы определить нечеткий хеш образца, выполните следующую команду:

# In[ ]:


get_ipython().system('ssdeep samples/test')


# Чтобы продемонстрировать использование нечеткого хеширования, рассмотрим в качестве примера директорию, состоящую из трех образцов вредоносного ПО. 
# 
# В следующем фрагменте кода видно, что все три файла имеют совершенно разные значения хеш-функций MD5:

# In[ ]:


get_ipython().system('ls samples')


# In[ ]:


get_ipython().system('md5sum samples/*')


# Режим *изящного сравнения* (опция ```-p```) в ```ssdeep``` может использоваться для определения процентного сходства. Из трех образцов два имеют сходство 93%, что предполагает, что они, вероятно, принадлежат к одному и тому же семейству вредоносных программ:

# In[ ]:


get_ipython().system('ssdeep -pb samples/test_01 samples/test_02 samples/test_03')


# Как показано в предыдущем примере, криптографические хеш-функции не помогли установить связь между образцами, тогда как метод нечеткого хеширования выявил сходство. 
# 
# Можно запустить ```ssdeep``` для каталогов и подкаталогов, содержащих вредоносные образцы, используя рекурсивный режим (```-r```):

# In[ ]:


get_ipython().system('ssdeep -lrpa samples/')


# В следующем примере ssdeep-хеши всех файлов были перенаправлены в текстовый файл (```all_hashes.txt```), а затем подозрительный файл (```test_03```) сопоставляется со всеми хешами в файле: 

# In[ ]:


get_ipython().system('ssdeep samples/test_01 samples/test_02 samples/test_03 > samples/all_hashes.txt')


# In[ ]:


get_ipython().system('cat samples/all_hashes.txt')


# В следующем фрагменте кода видно, что подозрительный файл (```test_03```) идентичен ```test_03``` (соответствие – 100%) и имеет сходство 93% с ```test_02```. Можно использовать этот метод для сравнения любого нового файла с хешами ранее проанализированных образцов:

# In[ ]:


get_ipython().system('ssdeep -m samples/all_hashes.txt samples/test_03')


# В Python нечеткий хеш может быть вычислен с использованием ```python-ssdeep```:

# In[ ]:


get_ipython().system('pip3 install ssdeep')


# In[ ]:


import ssdeep
hash1 = ssdeep.hash_from_file('samples/test_03')
print(hash1)


# In[ ]:


hash2 = ssdeep.hash_from_file('samples/test_02')
print(hash2)


# In[ ]:


ssdeep.compare(hash1, hash2)


# In[ ]:




